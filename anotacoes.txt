                           4
                        /     \
                      2         8
                    /   \     /   \
                   1     3   6     9
                           /   \
                          5     7

Pré-ordem: 4,2,1,3,8,6,5,7,9

Visita
verifica se tem filho a esquerda, se tiver: visita (desce), repete
senão verifica a direita, se tiver: visita e repete
senão sobe, repete


Pós-ordem: 1,3,2,5,7,6,9,8,4
Em-ordem:  1,2,3,4,5,6,7,8,9
Em-nível:  4,2,8,1,3,6,9,5,7

---------------------------------------------------------------------------

Montar árvore 10,20,30,40,50,60,70

1º > iserindo 10       | 10 |   FB = 0

---------------------------------------

2º > inserindo 20      | 10 |   FB = -1
                            \
                           | 20 |

---------------------------------------

3º > inserindo 30    0 | 10 | -2  FB = -2  A árvore fica desbalanceada em 10 pois tem 
                            \              2 filhos à direita e 0 à esquerda.
                         0 | 20 | -1       Será necessário efetuar rotação à esquerda
                                \          de 10, já que 3 nodos à direita.
                             0 | 30 | 0 

---------------------------------------

4º > rotação à            1 | 20 | -1  FB = 0    Agora a árvore está balaceada e 
     esquerda de 10         /    \               com Fator de Balanceamento igual 
                           /      \              à 0.
                    0 | 10 | 0  0 | 30 | 0 

---------------------------------------

5º > inserindo 40         1 | 20 | -2  FB = -1   A árvore não está desbalanceada pois
                           /      \              tem FB = -1 no nodo 30.
                          /        \              
                    0 | 10 | 0  0 | 30 | -1
                                      \
                                       \
                                    0 | 40 | 0

----------------------------------------

6º > inserindo 50       1 | 20 | -3  FB = -2     A árvore fica desbalanceada em 30
                         /      \                tem FB = -2. Será necessário realizar
                        /        \               rotação à esquerda de 30 (pois está 
                  0 | 10 | 0  0 | 30 | -2        desregulado à direita).
                                    \            Assim, balanceamos a árvore.
                                     \           
                                  0 | 40 | -1    
                                        \        
                                         \
                                      0 | 50 | 0

-----------------------------------------

7º > rotação à          1 | 20 | -2  FB = -1     A árvore fica desbalanceada em 30
     esquerda de 30      /      \                tem FB = -2. Será necessário realizar
                        /        \               rotação à esquerda de 30 (pois está 
                  0 | 10 | 0  1 | 40 | -1        desregulado à direita).
                                /    \           Assim, balanceamos a árvore.
                               /      \           
                        0 | 30 | 0  0 | 50 | 0    
                                        


Lógica que remove o root, eleva o subtree com mais filhos e adiciona o ex-root com a subtree menor como filho.
// else if (leftTree.length > rightTree.length) {
            //     Tree util = new Tree(this.node.getKey());
            //     util.setRightSubTree(this.getRightSubTree());
            //     this.length -= util.length;
            //     this.node = leftTree.getNode();
            //     this.setLeftSubTree(leftTree.getLeftSubTree());
            //     this.setRightSubTree(leftTree.getRightSubTree());
            //     this.addNode(util);
            //     updateIfIsFull();
            //     return this.balancing();
            // } else {
            //     Tree util = new Tree(this.node.getKey());
            //     util.setLeftSubTree(this.getLeftSubTree());
            //     this.length -= util.length;
            //     this.node = rightTree.getNode();
            //     this.setRightSubTree(rightTree.getRightSubTree());
            //     this.setLeftSubTree(rightTree.getLeftSubTree());
            //     this.addLeft(util);
            //     this.length += util.length;
            //     updateIfIsFull();
            //     return this.balancing();
            // }



    // updateBalaceFactorAntigo
    //     Tree leftTree = this.getLeftSubTree();
    //     Tree rightTree = this.getRightSubTree();
    //     if(leftTree == null && rightTree == null)
    //         return false;

    //     if(leftTree != null && rightTree != null) {
    //         int left = leftTree.getBalanceFactor();
    //         int right = rightTree.getBalanceFactor();
    //         this.balanceFactor = left - ((left > 0 && right < 0) ? (right * -1) : right);
    //     }
    //     if(leftTree == null && rightTree.length > 1) {
    //         int right = rightTree.getBalanceFactor();
    //         this.balanceFactor = (right < 0) ? (right * -1) : right;
    //     }
    //     if(rightTree == null && leftTree.length > 1) {
    //         int left = leftTree.getBalanceFactor();
    //         this.balanceFactor = (left < 0) ? (left * -1) : left;
    //     }
    //     return true;

     // if (leftBF == 0 && this.getRightSubTree().isFull && this.getRightSubTree().length > 1)
        //     rightBF += (rightBF < 0) ? -1 : 1;
        // if (rightBF == 0 && this.getLeftSubTree().isFull && this.getLeftSubTree().length > 1)
        //     leftBF += (leftBF < 0) ? -1 : 1;
        
        // if (rightBF < 0)
        //     rightBF *= -1;
        // if (leftBF < 0)
        //     leftBF *= -1;
        
        // if (leftBF == 0 && this.balanceFactor == -1) {
        //     if (this.getRightSubTree() != null && rightBF == 1 && this.getRightSubTree().balanceFactor == -1)
        //         return this.getRightSubTree().balanceFactor - rightBF;
        //     if (this.getLeftSubTree().length > 1)
        //         return 0;
        //     return -(rightBF + this.balanceFactor * -1);
        // } else if (rightBF == 0 && this.balanceFactor == 1) {
        //     if (this.getRightSubTree().length > 1)
        //         return leftBF + this.balanceFactor;
        // } 






         /** Retorna a altura da árvore */

        
        /*
         * após adicionar o nodo, vê se não há filhos
         * se sim, altura soma 1.
         * senão, recebe altura = altura do filho maior.
         * soma 1. 
         */
         

        // /** Retorna o fator de balanceamento da árvore com raiz t */

        // private int getFactor (AvlNode t) {

        //     return height( t.left ) - height( t.right );

        // }






         // else if (leftTree.length - rightTree.length >= 2) {
            //     Tree util = new Tree(this.node.getKey());
            //     util.setRightSubTree(this.getRightSubTree());
            //     this.length -= util.length;
            //     this.node = leftTree.getNode();
            //     this.setLeftSubTree(leftTree.getLeftSubTree());
            //     this.setRightSubTree(leftTree.getRightSubTree());
            //     this.addNode(util);
            //     updateIfIsFull();
            //     return this.balancing();
            // }
            // else if (leftTree.length - rightTree.length <= -2) {
            //     Tree util = new Tree(this.node.getKey());
            //     util.setLeftSubTree(this.getLeftSubTree());
            //     this.length -= util.length;
            //     this.node = rightTree.getNode();
            //     this.setRightSubTree(rightTree.getRightSubTree());
            //     this.setLeftSubTree(rightTree.getLeftSubTree());
            //     this.addLeft(util);
            //     updateIfIsFull();
            //     return this.balancing();
            // }
            // Se a árvore estiver cheia e o FB não for 0
            // if (this.isFull && this.balanceFactor != 0) {
            //     return this.balancing();
            // }










            util = new Tree(this.node.getKey());
                    util.insert(this.getLeftSubTree());
                    this.node = rightTree.getNode();
                    util.addRight(rightTree.getLeftSubTree());
                    util.length += rightTree.getLeftSubTree().length;
                    this.length -= util.length;
                    this.addLeft(util);
                    this.addRight(rightTree.getRightSubTree());
                    // this.getLeftSubTree().leftSubTree = util;
                    // this.getLeftSubTree().length += util.length;
                    this.length += util.length;
                    this.getLeftSubTree().balancing();
                    this.getLeftSubTree().updateBalanceFactor();
                    this.getRightSubTree().balancing();
                    updateBalanceFactor();
                    return this.contains(util.getNode());




            if (leftTree.balanceFactor != 0) {
                util = new Tree(this.node.getKey());
                util.insert(this.getRightSubTree());
                this.length -= util.length;
                this.node = leftTree.getNode();
                this.addLeft(leftTree.getLeftSubTree());
                this.addRight(leftTree.getRightSubTree());
                this.getRightSubTree().rightSubTree = util;
                this.getRightSubTree().length += util.length;
                this.length += util.length;
                this.getRightSubTree().balancing();
                this.getRightSubTree().updateBalanceFactor();
                this.getLeftSubTree().balancing();
                updateBalanceFactor();
                return this.contains(util.getNode());
            } else {
                util = new Tree(this.node.getKey());
                util.insert(this.getLeftSubTree());
                this.length -= util.length;
                this.node = rightTree.getNode();
                this.addLeft(rightTree.getLeftSubTree());
                this.addRight(rightTree.getRightSubTree());
                this.getLeftSubTree().leftSubTree = util;
                this.getLeftSubTree().length += util.length;
                this.length += util.length;
                this.getLeftSubTree().balancing();
                this.getLeftSubTree().updateBalanceFactor();
                this.getRightSubTree().balancing();
                updateBalanceFactor();
                return this.contains(util.getNode());